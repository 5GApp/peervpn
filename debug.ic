/***************************************************************************
 *   Copyright (C) 2008 by Tobias Volk                                     *
 *   mail@tobiasvolk.de                                                    *
 *                                                                         *
 *   This program is free software: you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/


#if DEBUG_LEVEL > 0


static void printPeerAddrOfHostname(char *hostname) {
	char debugipstring[PEERADDR_LENGTH*2+1];
	struct s_peeraddr debugpeeraddr;
	if(setPeerAddrByName(&debugpeeraddr,hostname,"0")) {
		byteArrayToString(debugipstring,debugpeeraddr.addr,PEERADDR_LENGTH);
		printf("%s -> %s\n",hostname,debugipstring);
	}
	else {
		printf("%s -> not found\n",hostname);		
	}
}


static void printMemoryOverview() {
	int i,pos;
	char ipstring[(PEERADDR_LENGTH*2)+1];
	char clientstring[(CLIENTID_LENGTH*2)+1];

	printf("status information:\n");
	printf("  server:\n");
	printf("    uptime: %d\n", getUptime());
	printf("    active peers: %d\n", g_peertable.fwdcount);
	printf("    active macs: %d\n", g_mactree.nodecount);
	printf("  active peer list:\n");
	for(i=0; i<g_peertable.fwdcount; i++) {
		pos = g_peertable.fwdlookup[i];
		byteArrayToString(ipstring,g_peertable.addr[pos].addr,PEERADDR_LENGTH);
		byteArrayToString(clientstring,g_peertable.clientid[pos].id,CLIENTID_LENGTH);
		printf("    #%03d: peerid=0x%02X, clientid=%s, addr=%s, lastseen=%d\n", i, pos, clientstring, ipstring, getUptime() - g_peertable.lastseen[pos]);
	}
	printf("  peertable listing (current clock: %d):\n", g_peertable.clockn);
	for(i=0; i<PEERCOUNT_HARDLIMIT; i++) {
		byteArrayToString(ipstring,g_peertable.addr[i].addr,PEERADDR_LENGTH);
		byteArrayToString(clientstring,g_peertable.clientid[i].id,CLIENTID_LENGTH);
		printf("    #0x%02X: status=%d, clientid=%s, addr=%s, lastseen=%d\n", i, g_peertable.status[i], clientstring, ipstring, getUptime() - g_peertable.lastseen[i]);
	}
	printf("  mactable listing\n");
	for(i=0; i<g_mactree.nodecount; i++) {
		byteArrayToString(ipstring,g_mactree.key[i],MACTREE_KEYSIZE);
		printf("    #%04d: mac=%s, peerid=0x%02X\n", i, ipstring, g_mactree.value[i][0]);
	}	
	printf("\n");
}


static void throwErrorDBG(char *str) {
	printf("debug error!\n");
	printMemoryOverview();
	throwError(str);
}


static void consistencyChecks() {
	int i,j,pos,rev;
	u_int8_t relayid = 0;
	for(i=0; i<g_peertable.fwdcount; i++) for(j=0; j<g_peertable.fwdcount; j++) if(i != j) {
		if(g_peertable.fwdlookup[i] == g_peertable.fwdlookup[j]) {
			throwErrorDBG("this should never happen! lookup table inconsistency!\n");
		}
	}
	for(i=0; i<g_peertable.fwdcount; i++) {
		pos = g_peertable.fwdlookup[i];
		rev = g_peertable.revlookup[pos];
		if(rev != i) {
			throwErrorDBG("this should never happen! lookup table inconsistency!\n");
		}
	}
	j=0;
	for(i=0; i<PEERCOUNT_HARDLIMIT; i++) {
		if(g_peertable.status[i] >= PEERSTATUS_CONFIRMED) {
			pos = g_peertable.revlookup[i];
			if(!(pos < g_peertable.fwdcount)) {
				throwErrorDBG("this should never happen! lookup table inconsistency!\n");
			}
			j++;
		}
	}
	if(j != g_peertable.fwdcount) {
		throwErrorDBG("this should never happen! lookup table inconsistency!\n");
	}
	for(i=0; i<PEERCOUNT_HARDLIMIT; i++) {
		if(g_peertable.status[i] != PEERSTATUS_INVALID && isRelayAddress(&g_peertable.addr[i],&relayid,NULL)) {
			if(!(relayid < PEERCOUNT_HARDLIMIT)) throwErrorDBG("this should never happen! invalid peerid referenced in relay address!\n");
			if(g_peertable.status[relayid] < PEERSTATUS_CONFIRMED) throwErrorDBG("this should never happen! inactive peerid referenced in relay address!\n");
			if(isRelayAddress(&g_peertable.addr[relayid],NULL,NULL)) throwErrorDBG("this should never happen! indirect connection depends on another indirect connection!\n");
		}
	}
	for(i=0; i<PEERCOUNT_HARDLIMIT; i++) {
		if(g_peertable.status[i] == PEERSTATUS_UNCONFIRMED_HS0 && g_peertable.ownid[i] != PEERID_ANONYMOUS) throwErrorDBG("this should never happen! lookup table inconsistency!\n");
	}
}


#endif
