/***************************************************************************
 *   Copyright (C) 2008 by Tobias Volk                                     *
 *   mail@tobiasvolk.de                                                    *
 *                                                                         *
 *   This program is free software: you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/


// returns program uptime
static int getUptime() {
	return (time(0) - g_starttime);
}


// converts a big endian byte array to a hexstring (size of *out must be 2*len+1)
static void byteArrayToString(char *out, u_int8_t *in, int len) {
	int i;
	out[0] = '\0';
	for(i=0; i<len; i++) sprintf(&out[i*2], "%02X", in[i]);
}


// terminates program with error message
static void throwError(char *msg) {
	if(msg != NULL) printf("error: %s\n",msg);
	exit(1);
}


// generates warning message
static void logWarning(char *msg) {
	if(msg != NULL) printf("warning: %s\n",msg);
}


// generate pseudo-random bytes
static void genRandomBytes(u_int8_t *rnd, int len) {
	RAND_pseudo_bytes((unsigned char *)rnd, len);	
}


// generate random number
static int getRandomNumber(int max) {
	int rnd;
	genRandomBytes((u_int8_t *)&rnd, sizeof(int));
	if(max > 0) {
		return (abs(rnd) % max);
	}
	else {
		return (abs(rnd));
	}
}


// randomize an array
static void randomizeUInt8Array(u_int8_t *array, int length) {
	u_int8_t swap;
	int i,r;
	for(i=0; i<length; i++) {
		r = getRandomNumber(length);
		swap = array[i];
		array[i] = array[r];
		array[r] = swap;
	}
}


// calculates nibble from hexcode
static u_int8_t getNibbleFromHexcode(char code) {
	if(code >= '0' && code <= '9') {
		return (code - '0');
	}
	else if(code >= 'a' && code <= 'f') {
		return ((code - 'a') + 10);
	}
	else if(code >= 'A' && code <= 'F') {
		return ((code - 'A') + 10);
	}
	else {
		return 0;
	}
}


// calculates byte from hexcode
static u_int8_t getByteFromHexcode(char upper, char lower) {
	return ((getNibbleFromHexcode(upper) << 4) + (getNibbleFromHexcode(lower)));
}


// returns true if char is hexcode
static u_int8_t isHexcode(char c) {
	return ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'));
}


// returns true if char is whitespace
static int isWhitespaceChar(char c) {
	switch(c) {
		case ' ':
		case '\t':
			return 1;
		default:
			return 0;
	}
}


// converts a hexstring to a byte array
static int hexStringToByteArray(char *hexstr, u_int8_t *bytearray, int bytearraylen) {
	int h;
	int i=0;
	while(i<bytearraylen) {
		h = 2*i;
		if(!isHexcode(hexstr[h])) {
			break;
		}
		else if(!isHexcode(hexstr[h+1])) {
			bytearray[i] = getByteFromHexcode(hexstr[h],'0');
			i++;
			break;
		}
		else {
			bytearray[i] = getByteFromHexcode(hexstr[h],hexstr[h+1]);
			i++;
		}
	}
	h=i;
	while(i<bytearraylen) {
		bytearray[i] = 0;
		i++;
	}
	return h; // return number of converted bytes
}


// convert char to 6 bit integer
static u_int8_t get6BitCodeFromChar(char ch) {
	if(ch >= '0' && ch <= '9') {
		return 1 + (ch - '0');
	}
	else if(ch >= 'a' && ch <= 'z') {
		return 11 + 2*(ch - 'a');
	}
	else if(ch >= 'A' && ch <= 'Z') {
		return 12 + 2*(ch - 'A');
	}
	else if(ch == '-') {
		return 63;
	}
	else {
		return 0;
	}
}


// convert 6 bit integer to char
static char getCharFrom6BitCode(u_int8_t cd) {
	if(cd >= 1 && cd <= 10) {
		return '0' + (cd - 1);
	}
	else if(cd >= 11 && cd <= 62) {
		if(cd % 2 == 0) {
			return 'A' + ((cd - 11)/2);
		}
		else {
			return 'a' + ((cd - 11)/2);
		}
	}
	else if(cd == 63) {
		return '-';
	}
	else {
		return '_';
	}
}


// generate network id form name
static void genNetID(struct s_netid *netid, char *str) {
	u_int8_t c0,c1,c2,c3;
	int strlen = ((NETID_LENGTH*4)/3)+4;
	int i;
	char netstr[strlen];
	for(i=0; i<strlen; i++) netstr[i] = 0;
	strncpy(netstr,str,strlen);
	for(i=0; ((i*3) < NETID_LENGTH); i++) {
		c0 = get6BitCodeFromChar(netstr[i*4+0]);
		c1 = get6BitCodeFromChar(netstr[i*4+1]);
		c2 = get6BitCodeFromChar(netstr[i*4+2]);
		c3 = get6BitCodeFromChar(netstr[i*4+3]);
		netid->id[i*3+0] = ((c0 << 2) & 252) | ((c1 >> 4) & 3);
		netid->id[i*3+1] = ((c1 << 4) & 240) | ((c2 >> 2) & 15);
		netid->id[i*3+2] = ((c2 << 6) & 192) | (c3 & 63);
	}
	
}


// generate network name from id
static void genNetStr(char *str, struct s_netid *netid) {
	u_int8_t c0,c1,c2,c3;
	int i = 0;
	while((i*3) < NETID_LENGTH) {
		c0 = ((netid->id[i*3+0] >> 2) & 63);
		c1 = ((netid->id[i*3+0] << 4) & 48) | ((netid->id[i*3+1] >> 4) & 15);
		c2 = ((netid->id[i*3+1] << 2) & 60) | ((netid->id[i*3+2] >> 6) & 3);
		c3 = (netid->id[i*3+2] & 63);
		str[i*4] = getCharFrom6BitCode(c0);
		str[i*4+1] = getCharFrom6BitCode(c1);
		str[i*4+2] = getCharFrom6BitCode(c2);
		str[i*4+3] = getCharFrom6BitCode(c3);
		i++;
	}
	str[(i*4)] = 0;
	while(i > 0) {
		i--;
		if(str[(i*4)+3] != '_') break;
		str[(i*4)+3] = 0;
		if(str[(i*4)+2] != '_') break;
		str[(i*4)+2] = 0;
		if(str[(i*4)+1] != '_') break;
		str[(i*4)+1] = 0;
		if(str[(i*4)] != '_') break;
		str[(i*4)] = 0;
	}
}


// compare network ids
static int compareNetIDs(struct s_netid *a, struct s_netid *b) {
	if(memcmp(a,b,NETID_LENGTH) == 0) {
		return 1;
	}
	else {
		return 0;
	}
}


// generate client id
static void genClientID(struct s_clientid *clientid) {
	genRandomBytes(clientid->id,CLIENTID_LENGTH);
}


// compare client ids
static int compareClientIDs(struct s_clientid *a, struct s_clientid *b) {
	if(memcmp(a,b,CLIENTID_LENGTH) == 0) {
		return 1;
	}
	else {
		return 0;
	}
}


// compare peeraddrs
static int comparePeerAddrs(struct s_peeraddr *a, struct s_peeraddr *b) {
	if(memcmp(a->addr,b->addr,PEERADDR_LENGTH) == 0) {
		return 1;
	}
	else {
		return 0;
	}
}


// generate relay address
static void genRelayAddress(struct s_peeraddr *addr, u_int8_t relayid, u_int8_t peerid) {
	memset(&addr->addr[PEERADDR_IP_START],0,PEERADDR_IP_LENGTH);
	*(u_int8_t *)(&addr->addr[PEERADDR_PORT_START]) = relayid;
	*(u_int8_t *)(&addr->addr[PEERADDR_PORT_START+1]) = peerid;
}


// checks if address is a relay address
static int isRelayAddress(struct s_peeraddr *addr, u_int8_t *relayid, u_int8_t *peerid) {
	if(memcmp(&addr->addr[PEERADDR_IP_START],g_zeroaddr.addr,PEERADDR_IP_LENGTH) == 0) {
		if(relayid != NULL) *relayid = (u_int8_t)addr->addr[PEERADDR_PORT_START];
		if(peerid != NULL) *peerid = (u_int8_t)addr->addr[PEERADDR_PORT_START+1];
		return 1;
	}
	else {
		return 0;
	}
}



