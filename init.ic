/***************************************************************************
 *   Copyright (C) 2008 by Tobias Volk                                     *
 *   mail@tobiasvolk.de                                                    *
 *                                                                         *
 *   This program is free software: you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/


// handle termination signals
void sighandler(int sig) {
	g_mainloop = 0;
}


// initialization sequence
void init(struct s_initconfig *initconfig) {
	int c,i,j,k,l,m;
	struct s_peeraddr localaddr;
	char str[256];

	// initialize signal handler
	g_mainloop = 1;
	signal(SIGINT, sighandler);

	// initialize uptime counter and random generator
	g_starttime = time(0);
	srandom(g_starttime);

	// create data structures
	g_config.windowsize = initconfig->windowsize;
	g_config.enablerelay = initconfig->enablerelay;
	g_config.enableindirect = initconfig->enableindirect;
	g_config.psklen = initconfig->psklen;
	memcpy(g_config.psk,initconfig->psk,CRYPTO_PSKBUF_SIZE);
	genClientID(&g_clientid);
	genNetID(&g_netid,initconfig->networkname);
	memset(&g_saddr,0,sizeof(struct sockaddr_in6));
	g_saddr.sin6_family = AF_INET6;
	g_saddrlen = sizeof(struct sockaddr_in6);
	g_peertable.fwdcount = 0;
	g_peertable.clockn = 0;
	for(i=0; i<PEERCOUNT_HARDLIMIT; i++) g_peertable.status[i] = PEERSTATUS_INVALID;
	for(i=0; i<FDID_COUNT; i++) g_fd[i].fd = -1;
	mactableInit();

	// load initpeers
	i=0;j=0;k=0;l=0;m=0;
	*(u_int8_t *)(&g_config.initpeers[0]) = 0;
	for(;;) {
		c = initconfig->initpeers[i];
		if(m) {
			if(isWhitespaceChar(c) || c == '\0') {
				k=i;
				m=k-j;
				if(m>0) {
					if(m > 254) m = 254;
					*(u_int8_t *)(&g_config.initpeers[l]) = (m+1);
					memcpy(&g_config.initpeers[l+1],&initconfig->initpeers[j],m);
					g_config.initpeers[l+1+m] = '\0';
					l = l+2+m;
					*(u_int8_t *)(&g_config.initpeers[l]) = 0;
				}
				m=0;
			}
			if(c == '\0') break;
		}
		else {
			if(c == '\0') break;
			if(!isWhitespaceChar(c)) {
				m=1;
				j=i;
			}
		}
		i++;
	}

	// enable console
	if(initconfig->enableconsole) {
		g_fd[FDID_CONSOLE].fd = STDIN_FILENO;
		g_fd[FDID_CONSOLE].events = POLLIN;
		g_config.enableconsole = initconfig->enableconsole;
	}
	
	// open udp socket
	if((g_fd[FDID_SOCKET].fd = openUDPSocket(initconfig->sourceip, initconfig->sourceport, &localaddr)) < 0) throwError("could not open local socket!");
	g_fd[FDID_SOCKET].events = POLLIN;

	// open tap device
	if(initconfig->enableeth) {
		if((g_fd[FDID_TAP].fd = openTapDevice(initconfig->tapname)) < 0) {
			g_config.enableeth = 0;
			throwError("tap device could not be opened!");
		}
		else {
			g_config.enableeth = 1;
			g_fd[FDID_TAP].events = POLLIN;
			if(strlen(initconfig->upcmd) > 0) {
				// execute shell command
				if((system(initconfig->upcmd)) < 0) {
					throwError("upcmd failed!");
				}
			}
		}
	}
	else {
		g_config.enableeth = 0;
	}

	// drop privileges
	dropPrivileges(initconfig->userstr, initconfig->groupstr, initconfig->chrootstr);

	// setup crypto
	cryptoInit();
	
	// show client & network id
	printf("\n");
	byteArrayToString(str, localaddr.addr, PEERADDR_LENGTH);
	printf("Local Address: %s\n", str);
	byteArrayToString(str, g_clientid.id, CLIENTID_LENGTH);
	printf("Client ID: %s\n", str);
	byteArrayToString(str, g_netid.id, NETID_LENGTH);
	printf("Network ID: %s\n", str);
	genNetStr(str,&g_netid);
	printf("Network Name: %s\n", str);
	byteArrayToString(str, g_config.psk, g_config.psklen);
	printf("Shared key (%d bit): %s\n", g_config.psklen*8, str);
	printf("\n");

	// enter main loop
	printf("entering main loop...\n");
	printf("\n");
	mainLoop();
	printf("\nmain loop left.\n");

	// sign off
	signoffAllRemotePeers();

	// shutdown crypto
	cryptoShutdown();

	// close tap device
	if(!(g_fd[FDID_TAP].fd < 0)) {
		close(g_fd[FDID_TAP].fd);
		g_fd[FDID_TAP].fd = -1;
	}

	// close socket
	if(!(g_fd[FDID_SOCKET].fd < 0)) {
		close(g_fd[FDID_SOCKET].fd);
		g_fd[FDID_SOCKET].fd = -1;
	}

	// close console
	if(!(g_fd[FDID_CONSOLE].fd < 0)) {
		close(g_fd[FDID_CONSOLE].fd);
		g_fd[FDID_CONSOLE].fd = -1;
	}

	// exit
	printf("exit.\n");
}

