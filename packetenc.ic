/***************************************************************************
 *   Copyright (C) 2008 by Tobias Volk                                     *
 *   mail@tobiasvolk.de                                                    *
 *                                                                         *
 *   This program is free software: you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/


// declarations
static void encodePacket(char *pbuf, u_int16_t pllen, u_int8_t peerid, u_int8_t ptype);


// encode relayin packet
static void encodeRelayInPacket(u_int8_t peerid, u_int8_t targetid, char *rpbuf, int rpllen) {
	char pbuf[PACKET_BUFSIZE];
	if((PBYTE_PAYLOAD + rpllen + 1) < PACKET_BUFSIZE) {
		memcpy(&pbuf[PBYTE_PAYLOAD],rpbuf,rpllen);
		*(u_int8_t *)(&pbuf[PBYTE_PAYLOAD+rpllen]) = targetid;
		encodePacket(pbuf,(rpllen+1),peerid,PTYPE_RELAYIN);
	}
}


// encode packet and send to alternative destination
static void encodePacketAltDest(char *pbuf, u_int16_t pllen, u_int8_t peerid, u_int8_t ptype, struct s_peeraddr *altdest) {
	struct s_peeraddr *sendtoaddr;
	char digest[DIGEST_BUFSIZE];
	char cryptpbuf[PACKETCRYPT_BUFSIZE];
	char *activebuf;
	int len = pllen + PBYTE_PAYLOAD;
	int clen;
	u_int8_t relayid;
	u_int8_t relaypeerid;
	if(len < PACKET_BUFSIZE) {
		g_peertable.ownseq[peerid] = ((g_peertable.ownseq[peerid] + 1) % MAX_SEQ);
		*(u_int32_t *)(&pbuf[PBYTE_SEQ]) = htonl(g_peertable.ownseq[peerid]);
		*(u_int8_t *)(&pbuf[PBYTE_PEERID]) = g_peertable.ownid[peerid];
		*(u_int8_t *)(&pbuf[PBYTE_PTYPE]) = ptype;
		*(u_int16_t *)(&pbuf[PBYTE_PLLENGTH]) = htons(pllen);
		*(u_int32_t *)(&pbuf[PBYTE_IV]) = getRandomNumber(MAX_SEQ); // generate random iv

		if(calculateHash(digest, &pbuf[PBYTE_HDR], (HDR_SIZE+pllen)) >= DIGEST_SIZE) {
			memcpy(&pbuf[PBYTE_MD], digest, DIGEST_SIZE);

			// determine target address
			if(altdest == NULL) {
				sendtoaddr = &g_peertable.addr[peerid];
			}
			else {
				sendtoaddr = altdest;
			}


			if(isRelayAddress(sendtoaddr,&relayid,&relaypeerid)) {
				// packet destination is a relay address, it has to be encapsulated
				if(g_config.enableindirect) encodeRelayInPacket(relayid,relaypeerid,pbuf,len);
			}
			else {
				if(len > 0) {			
					if(g_config.psklen > 0) {
						// encrypt packet
						clen = pskCrypt(cryptpbuf,pbuf,len,1);
						activebuf = cryptpbuf;
					}
					else {
						clen = len;
						activebuf = pbuf;
					}

					// send the packet
					if(clen > 0 && clen < PACKETCRYPT_BUFSIZE) sendPacket(activebuf,clen,sendtoaddr);
					else logWarning("could not encrypt packet!");
				}
			}
		}
	}
}


// encode packet
static void encodePacket(char *pbuf, u_int16_t pllen, u_int8_t peerid, u_int8_t ptype) {
	encodePacketAltDest(pbuf, pllen, peerid, ptype, NULL);
}


// encode hello0 packet
static void encodeHello0Packet(u_int8_t peerid) {
	char pbuf[PACKET_BUFSIZE];
	memcpy(&pbuf[PBYTE_PAYLOAD],g_netid.id,NETID_LENGTH);
	memcpy(&pbuf[PBYTE_PAYLOAD+NETID_LENGTH],g_clientid.id,CLIENTID_LENGTH);
	*(u_int32_t *)(&pbuf[PBYTE_PAYLOAD+NETID_LENGTH+CLIENTID_LENGTH]) = htonl(g_peertable.remoteseq[peerid]);
	*(u_int8_t *)(&pbuf[PBYTE_PAYLOAD+NETID_LENGTH+CLIENTID_LENGTH+4]) = peerid;
	encodePacket(pbuf, NETID_LENGTH+CLIENTID_LENGTH+5, peerid, PTYPE_HELLO0);
}


// encode hello1 packet
static void encodeHello1Packet(u_int8_t peerid) {
	char pbuf[PACKET_BUFSIZE];
	memcpy(&pbuf[PBYTE_PAYLOAD],g_netid.id,NETID_LENGTH);
	memcpy(&pbuf[PBYTE_PAYLOAD+NETID_LENGTH],g_clientid.id,CLIENTID_LENGTH);
	*(u_int32_t *)(&pbuf[PBYTE_PAYLOAD+NETID_LENGTH+CLIENTID_LENGTH]) = htonl(g_peertable.remoteseq[peerid]);
	*(u_int8_t *)(&pbuf[PBYTE_PAYLOAD+NETID_LENGTH+CLIENTID_LENGTH+4]) = peerid;
	encodePacket(pbuf, NETID_LENGTH+CLIENTID_LENGTH+5, peerid, PTYPE_HELLO1);
}


// encode hello2 packet
static void encodeHello2Packet(u_int8_t peerid) {
	char pbuf[PACKET_BUFSIZE];
	encodePacket(pbuf, 0, peerid, PTYPE_HELLO2);
	// in a later version, the session key will be transmitted here
}


// encode ping packet
static void encodePingPacket(u_int8_t peerid) {
	char pbuf[PACKET_BUFSIZE];
	encodePacket(pbuf, 0, peerid, PTYPE_PING);
}


// encode ping packet to alternative address
static void encodePingPacketAltDest(u_int8_t peerid, struct s_peeraddr *addr) {
	char pbuf[PACKET_BUFSIZE];
	encodePacketAltDest(pbuf, 0, peerid, PTYPE_PING, addr);
}


// encode peerinfo packet
static void encodePeerInfoPacket(u_int8_t peerid) {
	char pbuf[PACKET_BUFSIZE];
	u_int8_t posarray[PEERCOUNT_HARDLIMIT];
	u_int8_t limit = g_peertable.fwdcount;
	u_int8_t pos;
	int bufpos = PBYTE_PAYLOAD;
	int i,c;
	c=0;
	for(i=0; i<limit; i++) {
		pos = g_peertable.fwdlookup[i];
		if(!isRelayAddress(&g_peertable.addr[pos],NULL,NULL)) {
			posarray[c] = g_peertable.fwdlookup[i];
			c++;
		}
	}
	limit = c;
	randomizeUInt8Array(posarray,limit);
	if(limit > PEERINFO_MAXDATA) limit = PEERINFO_MAXDATA;
	c=0;
	for(i=0; i<limit; i++) {
		pos = posarray[i];
		memcpy(&pbuf[bufpos],&g_peertable.addr[pos],PEERADDR_LENGTH);
		bufpos = bufpos + PEERADDR_LENGTH;
		pbuf[bufpos] = pos;
		bufpos++;
		c++;
	}
	encodePacket(pbuf, c*(PEERADDR_LENGTH+1), peerid, PTYPE_PEERINFO);
}


// encode relayout packet
static void encodeRelayOutPacket(u_int8_t peerid, u_int8_t sourceid, char *pbuf, int pllen) {
	if((PBYTE_PAYLOAD + pllen + 1) < PACKET_BUFSIZE) {
		*(u_int8_t *)(&pbuf[PBYTE_PAYLOAD+pllen]) = sourceid;
		encodePacket(pbuf,(pllen+1),peerid,PTYPE_RELAYOUT);
	}
}


// encode signoff packet
static void encodeSignoffPacket(u_int8_t peerid) {
	char pbuf[PACKET_BUFSIZE];
	encodePacket(pbuf, 0, peerid, PTYPE_SIGNOFF);
}


// encode ethernet packet
static void encodeEthernetPacket(u_int8_t peerid, char *pbuf, int framelen) {
	encodePacket(pbuf, framelen, peerid, PTYPE_ETHERNET);
}
